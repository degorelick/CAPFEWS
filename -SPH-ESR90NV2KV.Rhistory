extra_tab_value = ""; if (year_tab >= 2020) {extra_tab_value = " T0"}
CAP_forecast = readxl::read_xlsx(path = "forecast Historical 2008 to 2021.xlsx",
sheet = paste(as.character(year_tab), extra_tab_value, sep = ""),
trim_ws = FALSE)
print(paste(as.character(year_tab), extra_tab_value, sep = ""))
# standardize basic column headers so we can be consistent between spreadsheets
n_columns_in_sheet = ncol(CAP_forecast)
sheet_columns_base_names = paste("C", as.character(c(1:n_columns_in_sheet)), sep="")
colnames(CAP_forecast) = sheet_columns_base_names
# extract commonly-formatted data
# first ~80% of each sheet has consistent formatting - last chunk of
# forecast data is a set titled TOTAL DELIVERIES BY CLASS
# that I will use as a flag to split up the data and read it
# consistently between tabs
final_first_set_row = which(stringr::str_squish(CAP_forecast$C1) == "TOTAL DELIVERIES")[
which(stringr::str_squish(CAP_forecast$C1) == "TOTAL DELIVERIES") >
which(stringr::str_squish(CAP_forecast$C1) == "TOTAL DELIVERIES BY CLASS")]
# there are consistent section headers in each year, with standard formatting
# so we can try to collect the info based on this?
SectionHeaders = c(CAP_forecast$C1[grepl("PP", stringr::str_squish(CAP_forecast$C1))],
"WADDELL PGP", "TOTAL SYSTEM DELIVERIES", "TOTAL DELIVERIES BY CLASS")
ColumnNames = c("Variable",
"Jan", "Feb", "Mar", "Q1",
"Apr", "May", "Jun", "Q2",
"Jul", "Aug", "Sep", "Q3",
"Oct", "Nov", "Dec", "Q4", "Total",
"Empty1", "Physical Turnout", "Empty2")[1:min(n_columns_in_sheet,21)]
all_sections = CAP_forecast[1,] %>%
rename_at(vars(colnames(CAP_forecast)[1:length(ColumnNames)]), function(x) ColumnNames) %>%
select(-grep("Empty", ColumnNames)) %>%
select(-grep("C", colnames(all_sections))) %>%
mutate(Group = NA, Subgroup = NA, Name = NA, Section = NA, Year = NA) %>% filter(!is.na(Jan))
for (section_name in SectionHeaders) {
# set bounds to read in each section of code
section_start_row = which(CAP_forecast$C1 == section_name)
section_end_row = min(which(CAP_forecast$C1 %in% SectionHeaders)[
which(CAP_forecast$C1 %in% SectionHeaders) > section_start_row], final_first_set_row+1, na.rm = TRUE)
# read in and organize
section = CAP_forecast[section_start_row:(section_end_row-1),] %>% filter(C1 != section_name) %>%
rename_at(vars(colnames(CAP_forecast)), function(x) ColumnNames) %>%
select(-grep("Empty", ColumnNames)) %>%
select(-grep("C", colnames(all_sections))) %>%
mutate(Group = NA, Subgroup = NA, Name = NA, Section = stringr::str_squish(section_name), Year = year_tab)
# based on indentations, sort into subcategory headers
temporary_group = NA; temporary_subgroup = NA; temporary_name = NA
for (row in 1:nrow(section)) {
if (is.na(section$Variable[row])) {next}
# longest indentations are names of users? more than 5 spaces of indentation
if (startsWith(stringr::str_squish(section$Variable[row]), "TOTAL")) {
temporary_group = section$Variable[row]; temporary_subgroup = NA; temporary_name = NA
} else if (startsWith(section$Variable[row], "      ")) {
temporary_name = section$Variable[row]
} else if (startsWith(section$Variable[row], " ")) {
temporary_subgroup = section$Variable[row]; temporary_name = NA
} else {
temporary_group = section$Variable[row]; temporary_subgroup = NA; temporary_name = NA
}
section$Group[row] = stringr::str_squish(temporary_group)
section$Subgroup[row] = stringr::str_squish(temporary_subgroup)
section$Name[row] = stringr::str_squish(temporary_name)
}
# clean up by dropping empty rows (mostly rows that just had headers in original file)
# and add to larger master set
section_clean = section %>% filter(!is.na(Jan))
all_sections = rbind(all_sections, section_clean)
}
# print to cleaned spreadsheet
write.csv(file = paste("cleaned_annual_forecast_first_section_", as.character(year_tab),".csv", sep = ""), x = all_sections)
}
View(all_sections)
for (year_tab in 2008:2021) {
# read in year tab
extra_tab_value = ""; if (year_tab >= 2020) {extra_tab_value = " T0"}
CAP_forecast = readxl::read_xlsx(path = "forecast Historical 2008 to 2021.xlsx",
sheet = paste(as.character(year_tab), extra_tab_value, sep = ""),
trim_ws = FALSE)
print(paste(as.character(year_tab), extra_tab_value, sep = ""))
# standardize basic column headers so we can be consistent between spreadsheets
n_columns_in_sheet = ncol(CAP_forecast)
sheet_columns_base_names = paste("C", as.character(c(1:n_columns_in_sheet)), sep="")
colnames(CAP_forecast) = sheet_columns_base_names
# extract commonly-formatted data
# first ~80% of each sheet has consistent formatting - last chunk of
# forecast data is a set titled TOTAL DELIVERIES BY CLASS
# that I will use as a flag to split up the data and read it
# consistently between tabs
final_first_set_row = which(stringr::str_squish(CAP_forecast$C1) == "TOTAL DELIVERIES")[
which(stringr::str_squish(CAP_forecast$C1) == "TOTAL DELIVERIES") >
which(stringr::str_squish(CAP_forecast$C1) == "TOTAL DELIVERIES BY CLASS")]
# there are consistent section headers in each year, with standard formatting
# so we can try to collect the info based on this?
SectionHeaders = c(CAP_forecast$C1[grepl("PP", stringr::str_squish(CAP_forecast$C1))],
"WADDELL PGP", "TOTAL SYSTEM DELIVERIES", "TOTAL DELIVERIES BY CLASS")
ColumnNames = c("Variable",
"Jan", "Feb", "Mar", "Q1",
"Apr", "May", "Jun", "Q2",
"Jul", "Aug", "Sep", "Q3",
"Oct", "Nov", "Dec", "Q4", "Total",
"Empty1", "Physical Turnout", "Empty2")[1:min(n_columns_in_sheet,21)]
# create master table to hold all years
if (year_tab == 2008) {
all_sections = CAP_forecast[1,] %>%
rename_at(vars(colnames(CAP_forecast)[1:length(ColumnNames)]), function(x) ColumnNames) %>%
select(-grep("Empty", ColumnNames)) %>%
select(-grep("C", colnames(all_sections))) %>%
mutate(Group = NA, Subgroup = NA, Name = NA, Section = NA, Year = NA) %>% filter(!is.na(Jan))
}
for (section_name in SectionHeaders) {
# set bounds to read in each section of code
section_start_row = which(CAP_forecast$C1 == section_name)
section_end_row = min(which(CAP_forecast$C1 %in% SectionHeaders)[
which(CAP_forecast$C1 %in% SectionHeaders) > section_start_row], final_first_set_row+1, na.rm = TRUE)
# read in and organize
section = CAP_forecast[section_start_row:(section_end_row-1),] %>% filter(C1 != section_name) %>%
rename_at(vars(colnames(CAP_forecast)), function(x) ColumnNames) %>%
select(-grep("Empty", ColumnNames)) %>%
select(-grep("C", colnames(all_sections))) %>%
mutate(Group = NA, Subgroup = NA, Name = NA, Section = stringr::str_squish(section_name), Year = year_tab)
# based on indentations, sort into subcategory headers
temporary_group = NA; temporary_subgroup = NA; temporary_name = NA
for (row in 1:nrow(section)) {
if (is.na(section$Variable[row])) {next}
# longest indentations are names of users? more than 5 spaces of indentation
if (startsWith(stringr::str_squish(section$Variable[row]), "TOTAL")) {
temporary_group = section$Variable[row]; temporary_subgroup = NA; temporary_name = NA
} else if (startsWith(section$Variable[row], "      ")) {
temporary_name = section$Variable[row]
} else if (startsWith(section$Variable[row], " ")) {
temporary_subgroup = section$Variable[row]; temporary_name = NA
} else {
temporary_group = section$Variable[row]; temporary_subgroup = NA; temporary_name = NA
}
section$Group[row] = stringr::str_squish(temporary_group)
section$Subgroup[row] = stringr::str_squish(temporary_subgroup)
section$Name[row] = stringr::str_squish(temporary_name)
}
# clean up by dropping empty rows (mostly rows that just had headers in original file)
# and add to larger master set
section_clean = section %>% filter(!is.na(Jan))
all_sections = rbind(all_sections, section_clean)
}
}
# print to cleaned spreadsheet
write.csv(file = paste("cleaned_annual_forecast_first_section_ALLYEARS.csv", sep = ""), x = all_sections)
rlang::last_error()
all_sections = CAP_forecast[1,] %>%
rename_at(vars(colnames(CAP_forecast)[1:length(ColumnNames)]), function(x) ColumnNames) %>%
select(-grep("Empty", ColumnNames)) %>%
select(-grep("C", colnames(all_sections))) %>%
mutate(Group = NA, Subgroup = NA, Name = NA, Section = NA, Year = NA) %>% filter(!is.na(Jan))
n_columns_in_sheet
ColumnNames
colnames(all_sections)
rm(list=ls()) # clear memory
setwd('C:/Users/dgorelic/OneDrive - University of North Carolina at Chapel Hill/UNC/Research/IM3/CAP/Data') # set directory
library(tidyverse)
year_tab = 2008
# read in year tab
extra_tab_value = ""; if (year_tab >= 2020) {extra_tab_value = " T0"}
CAP_forecast = readxl::read_xlsx(path = "forecast Historical 2008 to 2021.xlsx",
sheet = paste(as.character(year_tab), extra_tab_value, sep = ""),
trim_ws = FALSE)
print(paste(as.character(year_tab), extra_tab_value, sep = ""))
# standardize basic column headers so we can be consistent between spreadsheets
n_columns_in_sheet = ncol(CAP_forecast)
sheet_columns_base_names = paste("C", as.character(c(1:n_columns_in_sheet)), sep="")
colnames(CAP_forecast) = sheet_columns_base_names
# extract commonly-formatted data
# first ~80% of each sheet has consistent formatting - last chunk of
# forecast data is a set titled TOTAL DELIVERIES BY CLASS
# that I will use as a flag to split up the data and read it
# consistently between tabs
final_first_set_row = which(stringr::str_squish(CAP_forecast$C1) == "TOTAL DELIVERIES")[
which(stringr::str_squish(CAP_forecast$C1) == "TOTAL DELIVERIES") >
which(stringr::str_squish(CAP_forecast$C1) == "TOTAL DELIVERIES BY CLASS")]
# there are consistent section headers in each year, with standard formatting
# so we can try to collect the info based on this?
SectionHeaders = c(CAP_forecast$C1[grepl("PP", stringr::str_squish(CAP_forecast$C1))],
"WADDELL PGP", "TOTAL SYSTEM DELIVERIES", "TOTAL DELIVERIES BY CLASS")
ColumnNames = c("Variable",
"Jan", "Feb", "Mar", "Q1",
"Apr", "May", "Jun", "Q2",
"Jul", "Aug", "Sep", "Q3",
"Oct", "Nov", "Dec", "Q4", "Total",
"Empty1", "Physical Turnout", "Empty2")[1:min(n_columns_in_sheet,21)]
# create master table to hold all years
if (year_tab == 2008) {
all_sections = CAP_forecast[1,] %>%
rename_at(vars(colnames(CAP_forecast)[1:length(ColumnNames)]), function(x) ColumnNames) %>%
select(-grep("Empty", ColumnNames)) %>%
select(-grep("C", colnames(all_sections))) %>%
mutate(Group = NA, Subgroup = NA, Name = NA, Section = NA, Year = NA) %>% filter(!is.na(Jan))
}
# create master table to hold all years
if (year_tab == 2008) {
all_sections = CAP_forecast[1,] %>%
rename_at(vars(colnames(CAP_forecast)[1:length(ColumnNames)]), function(x) ColumnNames) %>%
select(-grep("Empty", ColumnNames))
all_sections %>%
select(-grep("C", colnames(all_sections))) %>%
mutate(Group = NA, Subgroup = NA, Name = NA, Section = NA, Year = NA) %>% filter(!is.na(Jan))
}
View(all_sections)
View(CAP_forecast)
all_sections = CAP_forecast[1,] %>%
rename_at(vars(colnames(CAP_forecast)[1:length(ColumnNames)]), function(x) ColumnNames) %>%
select(-grep("Empty", ColumnNames))
# create master table to hold all years
if (year_tab == 2008) {
all_sections = CAP_forecast[1,] %>%
rename_at(vars(colnames(CAP_forecast)[1:length(ColumnNames)]), function(x) ColumnNames) %>%
select(-grep("Empty", ColumnNames))
all_sections = all_sections %>%
select(-grep("C", colnames(all_sections))) %>%
mutate(Group = NA, Subgroup = NA, Name = NA, Section = NA, Year = NA) %>% filter(!is.na(Jan))
}
for (year_tab in 2008:2021) {
# read in year tab
extra_tab_value = ""; if (year_tab >= 2020) {extra_tab_value = " T0"}
CAP_forecast = readxl::read_xlsx(path = "forecast Historical 2008 to 2021.xlsx",
sheet = paste(as.character(year_tab), extra_tab_value, sep = ""),
trim_ws = FALSE)
print(paste(as.character(year_tab), extra_tab_value, sep = ""))
# standardize basic column headers so we can be consistent between spreadsheets
n_columns_in_sheet = ncol(CAP_forecast)
sheet_columns_base_names = paste("C", as.character(c(1:n_columns_in_sheet)), sep="")
colnames(CAP_forecast) = sheet_columns_base_names
# extract commonly-formatted data
# first ~80% of each sheet has consistent formatting - last chunk of
# forecast data is a set titled TOTAL DELIVERIES BY CLASS
# that I will use as a flag to split up the data and read it
# consistently between tabs
final_first_set_row = which(stringr::str_squish(CAP_forecast$C1) == "TOTAL DELIVERIES")[
which(stringr::str_squish(CAP_forecast$C1) == "TOTAL DELIVERIES") >
which(stringr::str_squish(CAP_forecast$C1) == "TOTAL DELIVERIES BY CLASS")]
# there are consistent section headers in each year, with standard formatting
# so we can try to collect the info based on this?
SectionHeaders = c(CAP_forecast$C1[grepl("PP", stringr::str_squish(CAP_forecast$C1))],
"WADDELL PGP", "TOTAL SYSTEM DELIVERIES", "TOTAL DELIVERIES BY CLASS")
ColumnNames = c("Variable",
"Jan", "Feb", "Mar", "Q1",
"Apr", "May", "Jun", "Q2",
"Jul", "Aug", "Sep", "Q3",
"Oct", "Nov", "Dec", "Q4", "Total",
"Empty1", "Physical Turnout", "Empty2")[1:min(n_columns_in_sheet,21)]
# create master table to hold all years
if (year_tab == 2008) {
all_sections = CAP_forecast[1,] %>%
rename_at(vars(colnames(CAP_forecast)[1:length(ColumnNames)]), function(x) ColumnNames) %>%
select(-grep("Empty", ColumnNames))
all_sections = all_sections %>%
select(-grep("C", colnames(all_sections))) %>%
mutate(Group = NA, Subgroup = NA, Name = NA, Section = NA, Year = NA) %>% filter(!is.na(Jan))
}
for (section_name in SectionHeaders) {
# set bounds to read in each section of code
section_start_row = which(CAP_forecast$C1 == section_name)
section_end_row = min(which(CAP_forecast$C1 %in% SectionHeaders)[
which(CAP_forecast$C1 %in% SectionHeaders) > section_start_row], final_first_set_row+1, na.rm = TRUE)
# read in and organize
section = CAP_forecast[section_start_row:(section_end_row-1),] %>% filter(C1 != section_name) %>%
rename_at(vars(colnames(CAP_forecast)), function(x) ColumnNames) %>%
select(-grep("Empty", ColumnNames)) %>%
select(-grep("C", colnames(all_sections))) %>%
mutate(Group = NA, Subgroup = NA, Name = NA, Section = stringr::str_squish(section_name), Year = year_tab)
# based on indentations, sort into subcategory headers
temporary_group = NA; temporary_subgroup = NA; temporary_name = NA
for (row in 1:nrow(section)) {
if (is.na(section$Variable[row])) {next}
# longest indentations are names of users? more than 5 spaces of indentation
if (startsWith(stringr::str_squish(section$Variable[row]), "TOTAL")) {
temporary_group = section$Variable[row]; temporary_subgroup = NA; temporary_name = NA
} else if (startsWith(section$Variable[row], "      ")) {
temporary_name = section$Variable[row]
} else if (startsWith(section$Variable[row], " ")) {
temporary_subgroup = section$Variable[row]; temporary_name = NA
} else {
temporary_group = section$Variable[row]; temporary_subgroup = NA; temporary_name = NA
}
section$Group[row] = stringr::str_squish(temporary_group)
section$Subgroup[row] = stringr::str_squish(temporary_subgroup)
section$Name[row] = stringr::str_squish(temporary_name)
}
# clean up by dropping empty rows (mostly rows that just had headers in original file)
# and add to larger master set
section_clean = section %>% filter(!is.na(Jan))
all_sections = rbind(all_sections, section_clean)
}
}
# print to cleaned spreadsheet
write.csv(file = paste("cleaned_annual_forecast_first_section_ALLYEARS.csv", sep = ""), x = all_sections)
# print to cleaned spreadsheet
write.csv(file = paste("cleaned_annual_forecast_first_section_ALLYEARS.csv", sep = ""), x = all_sections)
rlang::last_error()
section_name
# set bounds to read in each section of code
section_start_row = which(CAP_forecast$C1 == section_name)
section_end_row = min(which(CAP_forecast$C1 %in% SectionHeaders)[
which(CAP_forecast$C1 %in% SectionHeaders) > section_start_row], final_first_set_row+1, na.rm = TRUE)
# read in and organize
section = CAP_forecast[section_start_row:(section_end_row-1),] %>% filter(C1 != section_name) %>%
rename_at(vars(colnames(CAP_forecast)), function(x) ColumnNames) %>%
select(-grep("Empty", ColumnNames))
section = section %>%
select(-grep("C", colnames(section))) %>%
mutate(Group = NA, Subgroup = NA, Name = NA, Section = stringr::str_squish(section_name), Year = year_tab)
CAP_forecast[section_start_row:(section_end_row-1),] %>% filter(C1 != section_name)
CAP_forecast[section_start_row:(section_end_row-1),] %>% filter(C1 != section_name) %>%
rename_at(vars(colnames(CAP_forecast)), function(x) ColumnNames)
# read in and organize
section = CAP_forecast[section_start_row:(section_end_row-1),] %>% filter(C1 != section_name) %>%
rename_at(vars(colnames(CAP_forecast)[1:length(ColumnNames)]), function(x) ColumnNames) %>%
select(-grep("Empty", ColumnNames))
section = section %>%
select(-grep("C", colnames(section))) %>%
mutate(Group = NA, Subgroup = NA, Name = NA, Section = stringr::str_squish(section_name), Year = year_tab)
for (year_tab in 2008:2021) {
# read in year tab
extra_tab_value = ""; if (year_tab >= 2020) {extra_tab_value = " T0"}
CAP_forecast = readxl::read_xlsx(path = "forecast Historical 2008 to 2021.xlsx",
sheet = paste(as.character(year_tab), extra_tab_value, sep = ""),
trim_ws = FALSE)
print(paste(as.character(year_tab), extra_tab_value, sep = ""))
# standardize basic column headers so we can be consistent between spreadsheets
n_columns_in_sheet = ncol(CAP_forecast)
sheet_columns_base_names = paste("C", as.character(c(1:n_columns_in_sheet)), sep="")
colnames(CAP_forecast) = sheet_columns_base_names
# extract commonly-formatted data
# first ~80% of each sheet has consistent formatting - last chunk of
# forecast data is a set titled TOTAL DELIVERIES BY CLASS
# that I will use as a flag to split up the data and read it
# consistently between tabs
final_first_set_row = which(stringr::str_squish(CAP_forecast$C1) == "TOTAL DELIVERIES")[
which(stringr::str_squish(CAP_forecast$C1) == "TOTAL DELIVERIES") >
which(stringr::str_squish(CAP_forecast$C1) == "TOTAL DELIVERIES BY CLASS")]
# there are consistent section headers in each year, with standard formatting
# so we can try to collect the info based on this?
SectionHeaders = c(CAP_forecast$C1[grepl("PP", stringr::str_squish(CAP_forecast$C1))],
"WADDELL PGP", "TOTAL SYSTEM DELIVERIES", "TOTAL DELIVERIES BY CLASS")
ColumnNames = c("Variable",
"Jan", "Feb", "Mar", "Q1",
"Apr", "May", "Jun", "Q2",
"Jul", "Aug", "Sep", "Q3",
"Oct", "Nov", "Dec", "Q4", "Total",
"Empty1", "Physical Turnout", "Empty2")[1:min(n_columns_in_sheet,21)]
# create master table to hold all years
if (year_tab == 2008) {
all_sections = CAP_forecast[1,] %>%
rename_at(vars(colnames(CAP_forecast)[1:length(ColumnNames)]), function(x) ColumnNames) %>%
select(-grep("Empty", ColumnNames))
all_sections = all_sections %>%
select(-grep("C", colnames(all_sections))) %>%
mutate(Group = NA, Subgroup = NA, Name = NA, Section = NA, Year = NA) %>% filter(!is.na(Jan))
}
for (section_name in SectionHeaders) {
# set bounds to read in each section of code
section_start_row = which(CAP_forecast$C1 == section_name)
section_end_row = min(which(CAP_forecast$C1 %in% SectionHeaders)[
which(CAP_forecast$C1 %in% SectionHeaders) > section_start_row], final_first_set_row+1, na.rm = TRUE)
# read in and organize
section = CAP_forecast[section_start_row:(section_end_row-1),] %>% filter(C1 != section_name) %>%
rename_at(vars(colnames(CAP_forecast)[1:length(ColumnNames)]), function(x) ColumnNames) %>%
select(-grep("Empty", ColumnNames))
section = section %>%
select(-grep("C", colnames(section))) %>%
mutate(Group = NA, Subgroup = NA, Name = NA, Section = stringr::str_squish(section_name), Year = year_tab)
# based on indentations, sort into subcategory headers
temporary_group = NA; temporary_subgroup = NA; temporary_name = NA
for (row in 1:nrow(section)) {
if (is.na(section$Variable[row])) {next}
# longest indentations are names of users? more than 5 spaces of indentation
if (startsWith(stringr::str_squish(section$Variable[row]), "TOTAL")) {
temporary_group = section$Variable[row]; temporary_subgroup = NA; temporary_name = NA
} else if (startsWith(section$Variable[row], "      ")) {
temporary_name = section$Variable[row]
} else if (startsWith(section$Variable[row], " ")) {
temporary_subgroup = section$Variable[row]; temporary_name = NA
} else {
temporary_group = section$Variable[row]; temporary_subgroup = NA; temporary_name = NA
}
section$Group[row] = stringr::str_squish(temporary_group)
section$Subgroup[row] = stringr::str_squish(temporary_subgroup)
section$Name[row] = stringr::str_squish(temporary_name)
}
# clean up by dropping empty rows (mostly rows that just had headers in original file)
# and add to larger master set
section_clean = section %>% filter(!is.na(Jan))
all_sections = rbind(all_sections, section_clean)
}
}
# print to cleaned spreadsheet
write.csv(file = paste("cleaned_annual_forecast_first_section_ALLYEARS.csv", sep = ""), x = all_sections)
warnings()
# do some plotting!
unique(all_sections$Group)
head(aall_sections)
head(all_sections)
# results by month?
temp = ggplot(data = all_sections) +
geom_bar(aes(x = Year, y = as.numeric(Total), fill = Name), stat = "identity", color = NA) +
facet_wrap(Group ~ Section, scales = "free_y") + ylab('Units (see panel subtitles)') +
theme(axis.text.x = element_text(angle = 90)) + guides(fill = FALSE)
ggsave("visualization/CAP_forecast_actuals_2008_to_2021_test.png",
dpi = 400, units = "in", height = 10, width = 18)
# results by month?
temp = ggplot(data = all_sections) +
geom_bar(aes(x = Year, y = as.numeric(Total), fill = Group), stat = "identity", color = NA) +
facet_wrap(Section ~ ., scales = "free_y") + ylab('Units (see panel subtitles)') +
theme(axis.text.x = element_text(angle = 90)) + guides(fill = FALSE)
ggsave("visualization/CAP_forecast_actuals_2008_to_2021_test.png",
dpi = 400, units = "in", height = 10, width = 18)
# results by month?
temp = ggplot(data = all_sections) +
geom_bar(aes(x = Year, y = as.numeric(Total), fill = Group), stat = "identity", color = NA) +
facet_wrap(Section ~ ., scales = "free_y") + ylab('Units (see panel subtitles)') +
theme(axis.text.x = element_text(angle = 90))
ggsave("visualization/CAP_forecast_actuals_2008_to_2021_test.png",
dpi = 400, units = "in", height = 10, width = 20)
s = unique(all_sections$Section)[1]
s
plotter = all_sections %>% filter(all_sections$Section != s)
# results by month?
for (s in unique(all_sections$Section)) {
plotter = all_sections %>% filter(all_sections$Section != s)
temp = ggplot(data = plotter) +
geom_bar(aes(x = Year, y = as.numeric(Total), fill = Group), stat = "identity", color = NA) +
facet_wrap(Section ~ ., scales = "free_y") + ylab('Units (see panel subtitles)') +
theme(axis.text.x = element_text(angle = 90))
ggsave(paste("visualization/CAP_forecast_actuals_2008_to_2021_section", s, ".png", sep = ""),
dpi = 400, units = "in", height = 5, width = 8)
}
s
for (s in unique(all_sections$Section)) {
plotter = all_sections %>% filter(all_sections$Section == s)
temp = ggplot(data = plotter) +
geom_bar(aes(x = Year, y = as.numeric(Total), fill = Group), stat = "identity", color = NA) +
facet_wrap(Section ~ ., scales = "free_y") + ylab('Units (see panel subtitles)') +
theme(axis.text.x = element_text(angle = 90))
ggsave(paste("visualization/CAP_forecast_actuals_2008_to_2021_section", s, ".png", sep = ""),
dpi = 400, units = "in", height = 5, width = 8)
}
# results by month?
for (s in unique(all_sections$Section)) {
plotter = all_sections %>% filter(all_sections$Section == s) %>% filter(!grep("VOLUME PASSING", all_sections$Group))
temp = ggplot(data = plotter) +
geom_bar(aes(x = Year, y = as.numeric(Total), fill = Group), stat = "identity", color = NA) +
facet_wrap(Section ~ ., scales = "free_y") + ylab('Units (see panel subtitles)') +
theme(axis.text.x = element_text(angle = 90))
ggsave(paste("visualization/CAP_forecast_actuals_2008_to_2021_section", s, ".png", sep = ""),
dpi = 400, units = "in", height = 5, width = 8)
}
# results by month?
for (s in unique(all_sections$Section)) {
plotter = all_sections %>% filter(all_sections$Section == s) %>% filter(-grep("VOLUME PASSING", all_sections$Group))
temp = ggplot(data = plotter) +
geom_bar(aes(x = Year, y = as.numeric(Total), fill = Group), stat = "identity", color = NA) +
facet_wrap(Section ~ ., scales = "free_y") + ylab('Units (see panel subtitles)') +
theme(axis.text.x = element_text(angle = 90))
ggsave(paste("visualization/CAP_forecast_actuals_2008_to_2021_section", s, ".png", sep = ""),
dpi = 400, units = "in", height = 5, width = 8)
}
s
plotter = all_sections %>% filter(all_sections$Section == s) %>% filter(-grep("VOLUME PASSING", all_sections$Group))
plotter = all_sections %>% filter(all_sections$Section == s) %>% filter(-grep("VOLUME PASSING", Group))
plotter = all_sections %>% filter(all_sections$Section == s) %>% select(-grep("VOLUME PASSING", Group))
plotter = all_sections %>% filter(all_sections$Section == s) %>% select(-grep("VOLUME PASSING", all_sections$Group))
plotter = all_sections %>% filter(all_sections$Section == s) %>% filter(-contains("VOLUME PASSING"))
plotter = all_sections %>% filter(all_sections$Section == s) %>% filter(-grepl("VOLUME PASSING", Group))
plotter = all_sections %>% filter(all_sections$Section == s) %>% filter(-grepl("VOLUME PASSING", all_sections$Group))
all_sections %>% filter(all_sections$Section == s)
all_sections %>% filter(all_sections$Section == s) %>% filter(-grepl("VOLUME PASSING", Group))
plotter = all_sections %>% filter(all_sections$Section == s)
plotter = plotter %>% filter(-grepl("VOLUME PASSING", Group))
View(plotter)
plotter = plotter %>% filter(-grepl("VOLUME PASSING", Variable))
plotter = all_sections %>% filter(all_sections$Section == s) %>% filter(!grepl("VOLUME PASSING", Variable))
# results by month?
for (s in unique(all_sections$Section)) {
plotter = all_sections %>% filter(all_sections$Section == s) %>% filter(!grepl("VOLUME PASSING", Variable))
temp = ggplot(data = plotter) +
geom_bar(aes(x = Year, y = as.numeric(Total), fill = Group), stat = "identity", color = NA) +
facet_wrap(Section ~ ., scales = "free_y") + ylab('AF') +
theme(axis.text.x = element_text(angle = 90))
ggsave(paste("visualization/CAP_forecast_actuals_2008_to_2021_section", s, ".png", sep = ""),
dpi = 400, units = "in", height = 5, width = 8)
}
# results by month?
for (s in unique(all_sections$Section)) {
plotter = all_sections %>% filter(all_sections$Section == s) %>%
filter(!grepl("VOLUME PASSING", Variable)) %>%
filter(!grepl("TOTAL DELIVERIES", Variable)) %>%
filter(!grepl("SEGMENT DEMAND", Variable))
temp = ggplot(data = plotter) +
geom_bar(aes(x = Year, y = as.numeric(Total), fill = Group), stat = "identity", color = NA) +
facet_wrap(Section ~ ., scales = "free_y") + ylab('AF') +
theme(axis.text.x = element_text(angle = 90))
ggsave(paste("visualization/CAP_forecast_actuals_2008_to_2021_section", s, ".png", sep = ""),
dpi = 400, units = "in", height = 5, width = 8)
}
# results by month?
for (s in unique(all_sections$Section)) {
plotter = all_sections %>% filter(all_sections$Section == s) %>%
filter(!grepl("VOLUME PASSING", Variable)) %>%
filter(!grepl("TOTAL", Variable)) %>%
filter(!grepl("SEGMENT DEMAND", Variable))
temp = ggplot(data = plotter) +
geom_bar(aes(x = Year, y = as.numeric(Total), fill = Group), stat = "identity", color = NA) +
facet_wrap(Section ~ ., scales = "free_y") + ylab('AF') +
theme(axis.text.x = element_text(angle = 90))
ggsave(paste("visualization/CAP_forecast_actuals_2008_to_2021_section", s, ".png", sep = ""),
dpi = 400, units = "in", height = 5, width = 8)
}
